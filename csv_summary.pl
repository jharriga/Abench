
use strict;
use warnings;

my %results;

# input: output log file generated by the results_parser.pl and cert_median.pl

# Collect the best and single runs' medians for each workload
# Since best/single isn't printed in the log, I'm assuming 
# context == workers == 1 is a valid test (it'll be !1 or 'default').
while (<>) {
	chomp;
	next unless /median$/;
	my ($name, $contexts, $workers, $ips) = (split(/\s+/))[2, 3, 4, 8];
	my $type;
	if ($contexts eq "default" or $workers eq "default") {
		$type = "best";
	}
	elsif ($contexts == $workers and $contexts == 1) {
		$type = "single";
	}
	else {
		$type = "best";
	}

	$results{$name}{$type} = $ips;
}

# Now create a comparison table
printf "%-40s %10s %10s %10s\n", "", "Multicore", "Singlecore", "";
printf "%-40s %10s %10s %10s\n", "Workload Name", "(iter/s)", "(iter/s)", "Scaling";
printf "%-40s %10s %10s %10s\n", ('-' x 40), ('-' x 10), ('-' x 10), ('-' x 10);
foreach my $testName(sort keys %results) {
	my $best = $results{$testName}{'best'};
	my $single = $results{$testName}{'single'};
	my $scaling = 0;
	if (defined $best && defined $single && $single != 0) {
		$scaling = $best / $single
	}
	printf "%-40s, ", $testName;
	printf "%10s, ", defined $best ? sprintf("%.2f", $best) : "n/a";
	printf "%10s, ", defined $single ? sprintf("%.2f", $single) : "n/a";
	printf "%10.2f\n", $scaling;
}
